package generator

import (
	"html/template"
	"strings"
)

var functionFuncs template.FuncMap = template.FuncMap{
	"ToLower":  strings.ToLower,
	"UnExport": unexport,
	"Replace":  strings.Replace,
}

const functionTemplate string = `// Code generated by counterfeiter. DO NOT EDIT.
package {{.DestinationPackage}}

import (
	{{- range .Imports}}
	{{.Alias}} "{{.Path}}"
	{{- end}}
)

type {{.Name}} struct {
	Stub func({{.Method.Params.AsArgs}}) {{.Method.Returns.AsReturnSignature}}
	mutex sync.RWMutex
	argsForCall []struct{
		{{- range .Method.Params}}
		{{.Name}} {{if .IsVariadic}}{{Replace .Type "..." "[]" -1}}{{else}}{{.Type}}{{end}}
		{{- end}}
	}
	{{- if .Method.Returns.HasLength}}
	returns struct{
		{{- range .Method.Returns}}
		{{UnExport .Name}} {{.Type}}
		{{- end}}
	}
	returnsOnCall map[int]struct{
		{{- range .Method.Returns}}
		{{UnExport .Name}} {{.Type}}
		{{- end}}
	}
	{{- end}}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *{{.Method.FakeName}}) Spy({{.Method.Params.AsNamedArgsWithTypes}}) {{.Method.Returns.AsReturnSignature}} {
	{{- range .Method.Params.Slices}}
	var {{UnExport .Name}}Copy {{.Type}}
	if {{UnExport .Name}} != nil {
		{{UnExport .Name}}Copy = make({{.Type}}, len({{UnExport .Name}}))
		copy({{UnExport .Name}}Copy, {{UnExport .Name}})
	}
	{{- end}}
	fake.mutex.Lock()
	{{if .Method.Returns.HasLength}}ret, specificReturn := fake.returnsOnCall[len(fake.argsForCall)]
	{{end}}fake.argsForCall = append(fake.argsForCall, struct{
		{{- range .Method.Params}}
		{{.Name}} {{if .IsVariadic}}{{Replace .Type "..." "[]" -1}}{{else}}{{.Type}}{{end}}
		{{- end}}
	}{ {{- .Method.Params.AsNamedArgs -}} })
	fake.recordInvocation("{{.TargetName}}", []interface{}{ {{- if .Method.Params.HasLength}}{{.Method.Params.AsNamedArgs}}{{end -}} })
	fake.mutex.Unlock()
	if fake.Stub != nil {
		{{if .Method.Returns.HasLength}}return fake.Stub({{.Method.Params.AsNamedArgsForInvocation}}){{else}}fake.Stub({{.Method.Params.AsNamedArgsForInvocation}}){{end}}
	}
	{{- if .Method.Returns.HasLength}}
	if specificReturn {
		return {{.Method.Returns.WithPrefix "ret."}}
	}
	return {{.Method.Returns.WithPrefix "fake.returns."}}
	{{- end}}
}

func (fake *{{.Method.FakeName}}) CallCount() int {
	fake.mutex.RLock()
	defer fake.mutex.RUnlock()
	return len(fake.argsForCall)
}

{{if .Method.Params.HasLength -}}
func (fake *{{.Method.FakeName}}) ArgsForCall(i int) {{.Method.Params.AsReturnSignature}} {
	fake.mutex.RLock()
	defer fake.mutex.RUnlock()
	return {{.Method.Params.WithPrefix "fake.argsForCall[i]."}}
}
{{- end}}

{{if .Method.Returns.HasLength -}}
func (fake *{{.Method.FakeName}}) Returns({{.Method.Returns.AsNamedArgsWithTypes}}) {
	fake.Stub = nil
	fake.returns = struct {
		{{- range .Method.Returns}}
		{{UnExport .Name}} {{.Type}}
		{{- end}}
	}{ {{- .Method.Returns.AsNamedArgs -}} }
}

func (fake *{{.Method.FakeName}}) ReturnsOnCall(i int, {{.Method.Returns.AsNamedArgsWithTypes}}) {
	fake.Stub = nil
	if fake.returnsOnCall == nil {
		fake.returnsOnCall = make(map[int]struct {
			{{- range .Method.Returns}}
			{{UnExport .Name}} {{.Type}}
			{{- end}}
		})
	}
	fake.returnsOnCall[i] = struct {
		{{- range .Method.Returns}}
		{{UnExport .Name}} {{.Type}}
		{{- end}}
	}{ {{- .Method.Returns.AsNamedArgs -}} }
}
{{- end}}

func (fake *{{.Method.FakeName}}) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.mutex.RLock()
	defer fake.mutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *{{.Name}}) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ {{.TargetAlias}}.{{.TargetName}} = new({{.Name}}).Spy
`
