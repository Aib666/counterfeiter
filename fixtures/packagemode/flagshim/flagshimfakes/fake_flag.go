// Code generated by counterfeiter. DO NOT EDIT.
package flagshimfakes

import (
	"flag"
	"sync"
	"time"

	"github.com/maxbrunsfeld/counterfeiter/v6/fixtures/packagemode/flagshim"
)

type FakeFlag struct {
	ArgStub        func(int) string
	argMutex       sync.RWMutex
	argArgsForCall []struct {
		arg1 int
	}
	argReturns struct {
		result1 string
	}
	argReturnsOnCall map[int]struct {
		result1 string
	}
	ArgsStub        func() []string
	argsMutex       sync.RWMutex
	argsArgsForCall []struct {
	}
	argsReturns struct {
		result1 []string
	}
	argsReturnsOnCall map[int]struct {
		result1 []string
	}
	BoolStub        func(string, bool, string) *bool
	boolMutex       sync.RWMutex
	boolArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 string
	}
	boolReturns struct {
		result1 *bool
	}
	boolReturnsOnCall map[int]struct {
		result1 *bool
	}
	BoolVarStub        func(*bool, string, bool, string)
	boolVarMutex       sync.RWMutex
	boolVarArgsForCall []struct {
		arg1 *bool
		arg2 string
		arg3 bool
		arg4 string
	}
	DurationStub        func(string, time.Duration, string) *time.Duration
	durationMutex       sync.RWMutex
	durationArgsForCall []struct {
		arg1 string
		arg2 time.Duration
		arg3 string
	}
	durationReturns struct {
		result1 *time.Duration
	}
	durationReturnsOnCall map[int]struct {
		result1 *time.Duration
	}
	DurationVarStub        func(*time.Duration, string, time.Duration, string)
	durationVarMutex       sync.RWMutex
	durationVarArgsForCall []struct {
		arg1 *time.Duration
		arg2 string
		arg3 time.Duration
		arg4 string
	}
	Float64Stub        func(string, float64, string) *float64
	float64Mutex       sync.RWMutex
	float64ArgsForCall []struct {
		arg1 string
		arg2 float64
		arg3 string
	}
	float64Returns struct {
		result1 *float64
	}
	float64ReturnsOnCall map[int]struct {
		result1 *float64
	}
	Float64VarStub        func(*float64, string, float64, string)
	float64VarMutex       sync.RWMutex
	float64VarArgsForCall []struct {
		arg1 *float64
		arg2 string
		arg3 float64
		arg4 string
	}
	FuncStub        func(string, string, func(string) error)
	funcMutex       sync.RWMutex
	funcArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 func(string) error
	}
	IntStub        func(string, int, string) *int
	intMutex       sync.RWMutex
	intArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
	}
	intReturns struct {
		result1 *int
	}
	intReturnsOnCall map[int]struct {
		result1 *int
	}
	Int64Stub        func(string, int64, string) *int64
	int64Mutex       sync.RWMutex
	int64ArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 string
	}
	int64Returns struct {
		result1 *int64
	}
	int64ReturnsOnCall map[int]struct {
		result1 *int64
	}
	Int64VarStub        func(*int64, string, int64, string)
	int64VarMutex       sync.RWMutex
	int64VarArgsForCall []struct {
		arg1 *int64
		arg2 string
		arg3 int64
		arg4 string
	}
	IntVarStub        func(*int, string, int, string)
	intVarMutex       sync.RWMutex
	intVarArgsForCall []struct {
		arg1 *int
		arg2 string
		arg3 int
		arg4 string
	}
	LookupStub        func(string) *flag.Flag
	lookupMutex       sync.RWMutex
	lookupArgsForCall []struct {
		arg1 string
	}
	lookupReturns struct {
		result1 *flag.Flag
	}
	lookupReturnsOnCall map[int]struct {
		result1 *flag.Flag
	}
	NArgStub        func() int
	nArgMutex       sync.RWMutex
	nArgArgsForCall []struct {
	}
	nArgReturns struct {
		result1 int
	}
	nArgReturnsOnCall map[int]struct {
		result1 int
	}
	NFlagStub        func() int
	nFlagMutex       sync.RWMutex
	nFlagArgsForCall []struct {
	}
	nFlagReturns struct {
		result1 int
	}
	nFlagReturnsOnCall map[int]struct {
		result1 int
	}
	NewFlagSetStub        func(string, flag.ErrorHandling) *flag.FlagSet
	newFlagSetMutex       sync.RWMutex
	newFlagSetArgsForCall []struct {
		arg1 string
		arg2 flag.ErrorHandling
	}
	newFlagSetReturns struct {
		result1 *flag.FlagSet
	}
	newFlagSetReturnsOnCall map[int]struct {
		result1 *flag.FlagSet
	}
	ParseStub        func()
	parseMutex       sync.RWMutex
	parseArgsForCall []struct {
	}
	ParsedStub        func() bool
	parsedMutex       sync.RWMutex
	parsedArgsForCall []struct {
	}
	parsedReturns struct {
		result1 bool
	}
	parsedReturnsOnCall map[int]struct {
		result1 bool
	}
	PrintDefaultsStub        func()
	printDefaultsMutex       sync.RWMutex
	printDefaultsArgsForCall []struct {
	}
	SetStub        func(string, string) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setReturns struct {
		result1 error
	}
	setReturnsOnCall map[int]struct {
		result1 error
	}
	StringStub        func(string, string, string) *string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	stringReturns struct {
		result1 *string
	}
	stringReturnsOnCall map[int]struct {
		result1 *string
	}
	StringVarStub        func(*string, string, string, string)
	stringVarMutex       sync.RWMutex
	stringVarArgsForCall []struct {
		arg1 *string
		arg2 string
		arg3 string
		arg4 string
	}
	UintStub        func(string, uint, string) *uint
	uintMutex       sync.RWMutex
	uintArgsForCall []struct {
		arg1 string
		arg2 uint
		arg3 string
	}
	uintReturns struct {
		result1 *uint
	}
	uintReturnsOnCall map[int]struct {
		result1 *uint
	}
	Uint64Stub        func(string, uint64, string) *uint64
	uint64Mutex       sync.RWMutex
	uint64ArgsForCall []struct {
		arg1 string
		arg2 uint64
		arg3 string
	}
	uint64Returns struct {
		result1 *uint64
	}
	uint64ReturnsOnCall map[int]struct {
		result1 *uint64
	}
	Uint64VarStub        func(*uint64, string, uint64, string)
	uint64VarMutex       sync.RWMutex
	uint64VarArgsForCall []struct {
		arg1 *uint64
		arg2 string
		arg3 uint64
		arg4 string
	}
	UintVarStub        func(*uint, string, uint, string)
	uintVarMutex       sync.RWMutex
	uintVarArgsForCall []struct {
		arg1 *uint
		arg2 string
		arg3 uint
		arg4 string
	}
	UnquoteUsageStub        func(*flag.Flag) (string, string)
	unquoteUsageMutex       sync.RWMutex
	unquoteUsageArgsForCall []struct {
		arg1 *flag.Flag
	}
	unquoteUsageReturns struct {
		result1 string
		result2 string
	}
	unquoteUsageReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	VarStub        func(flag.Value, string, string)
	varMutex       sync.RWMutex
	varArgsForCall []struct {
		arg1 flag.Value
		arg2 string
		arg3 string
	}
	VisitStub        func(func(*flag.Flag))
	visitMutex       sync.RWMutex
	visitArgsForCall []struct {
		arg1 func(*flag.Flag)
	}
	VisitAllStub        func(func(*flag.Flag))
	visitAllMutex       sync.RWMutex
	visitAllArgsForCall []struct {
		arg1 func(*flag.Flag)
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFlag) Arg(arg1 int) string {
	fake.argMutex.Lock()
	ret, specificReturn := fake.argReturnsOnCall[len(fake.argArgsForCall)]
	fake.argArgsForCall = append(fake.argArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ArgStub
	fakeReturns := fake.argReturns
	fake.recordInvocation("Arg", []interface{}{arg1})
	fake.argMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) ArgCallCount() int {
	fake.argMutex.RLock()
	defer fake.argMutex.RUnlock()
	return len(fake.argArgsForCall)
}

func (fake *FakeFlag) ArgCalls(stub func(int) string) {
	fake.argMutex.Lock()
	defer fake.argMutex.Unlock()
	fake.ArgStub = stub
}

func (fake *FakeFlag) ArgArgsForCall(i int) int {
	fake.argMutex.RLock()
	defer fake.argMutex.RUnlock()
	argsForCall := fake.argArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFlag) ArgReturns(result1 string) {
	fake.argMutex.Lock()
	defer fake.argMutex.Unlock()
	fake.ArgStub = nil
	fake.argReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeFlag) ArgReturnsOnCall(i int, result1 string) {
	fake.argMutex.Lock()
	defer fake.argMutex.Unlock()
	fake.ArgStub = nil
	if fake.argReturnsOnCall == nil {
		fake.argReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.argReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeFlag) Args() []string {
	fake.argsMutex.Lock()
	ret, specificReturn := fake.argsReturnsOnCall[len(fake.argsArgsForCall)]
	fake.argsArgsForCall = append(fake.argsArgsForCall, struct {
	}{})
	stub := fake.ArgsStub
	fakeReturns := fake.argsReturns
	fake.recordInvocation("Args", []interface{}{})
	fake.argsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) ArgsCallCount() int {
	fake.argsMutex.RLock()
	defer fake.argsMutex.RUnlock()
	return len(fake.argsArgsForCall)
}

func (fake *FakeFlag) ArgsCalls(stub func() []string) {
	fake.argsMutex.Lock()
	defer fake.argsMutex.Unlock()
	fake.ArgsStub = stub
}

func (fake *FakeFlag) ArgsReturns(result1 []string) {
	fake.argsMutex.Lock()
	defer fake.argsMutex.Unlock()
	fake.ArgsStub = nil
	fake.argsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeFlag) ArgsReturnsOnCall(i int, result1 []string) {
	fake.argsMutex.Lock()
	defer fake.argsMutex.Unlock()
	fake.ArgsStub = nil
	if fake.argsReturnsOnCall == nil {
		fake.argsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.argsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeFlag) Bool(arg1 string, arg2 bool, arg3 string) *bool {
	fake.boolMutex.Lock()
	ret, specificReturn := fake.boolReturnsOnCall[len(fake.boolArgsForCall)]
	fake.boolArgsForCall = append(fake.boolArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.BoolStub
	fakeReturns := fake.boolReturns
	fake.recordInvocation("Bool", []interface{}{arg1, arg2, arg3})
	fake.boolMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) BoolCallCount() int {
	fake.boolMutex.RLock()
	defer fake.boolMutex.RUnlock()
	return len(fake.boolArgsForCall)
}

func (fake *FakeFlag) BoolCalls(stub func(string, bool, string) *bool) {
	fake.boolMutex.Lock()
	defer fake.boolMutex.Unlock()
	fake.BoolStub = stub
}

func (fake *FakeFlag) BoolArgsForCall(i int) (string, bool, string) {
	fake.boolMutex.RLock()
	defer fake.boolMutex.RUnlock()
	argsForCall := fake.boolArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) BoolReturns(result1 *bool) {
	fake.boolMutex.Lock()
	defer fake.boolMutex.Unlock()
	fake.BoolStub = nil
	fake.boolReturns = struct {
		result1 *bool
	}{result1}
}

func (fake *FakeFlag) BoolReturnsOnCall(i int, result1 *bool) {
	fake.boolMutex.Lock()
	defer fake.boolMutex.Unlock()
	fake.BoolStub = nil
	if fake.boolReturnsOnCall == nil {
		fake.boolReturnsOnCall = make(map[int]struct {
			result1 *bool
		})
	}
	fake.boolReturnsOnCall[i] = struct {
		result1 *bool
	}{result1}
}

func (fake *FakeFlag) BoolVar(arg1 *bool, arg2 string, arg3 bool, arg4 string) {
	fake.boolVarMutex.Lock()
	fake.boolVarArgsForCall = append(fake.boolVarArgsForCall, struct {
		arg1 *bool
		arg2 string
		arg3 bool
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.BoolVarStub
	fake.recordInvocation("BoolVar", []interface{}{arg1, arg2, arg3, arg4})
	fake.boolVarMutex.Unlock()
	if stub != nil {
		fake.BoolVarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) BoolVarCallCount() int {
	fake.boolVarMutex.RLock()
	defer fake.boolVarMutex.RUnlock()
	return len(fake.boolVarArgsForCall)
}

func (fake *FakeFlag) BoolVarCalls(stub func(*bool, string, bool, string)) {
	fake.boolVarMutex.Lock()
	defer fake.boolVarMutex.Unlock()
	fake.BoolVarStub = stub
}

func (fake *FakeFlag) BoolVarArgsForCall(i int) (*bool, string, bool, string) {
	fake.boolVarMutex.RLock()
	defer fake.boolVarMutex.RUnlock()
	argsForCall := fake.boolVarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) Duration(arg1 string, arg2 time.Duration, arg3 string) *time.Duration {
	fake.durationMutex.Lock()
	ret, specificReturn := fake.durationReturnsOnCall[len(fake.durationArgsForCall)]
	fake.durationArgsForCall = append(fake.durationArgsForCall, struct {
		arg1 string
		arg2 time.Duration
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DurationStub
	fakeReturns := fake.durationReturns
	fake.recordInvocation("Duration", []interface{}{arg1, arg2, arg3})
	fake.durationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) DurationCallCount() int {
	fake.durationMutex.RLock()
	defer fake.durationMutex.RUnlock()
	return len(fake.durationArgsForCall)
}

func (fake *FakeFlag) DurationCalls(stub func(string, time.Duration, string) *time.Duration) {
	fake.durationMutex.Lock()
	defer fake.durationMutex.Unlock()
	fake.DurationStub = stub
}

func (fake *FakeFlag) DurationArgsForCall(i int) (string, time.Duration, string) {
	fake.durationMutex.RLock()
	defer fake.durationMutex.RUnlock()
	argsForCall := fake.durationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) DurationReturns(result1 *time.Duration) {
	fake.durationMutex.Lock()
	defer fake.durationMutex.Unlock()
	fake.DurationStub = nil
	fake.durationReturns = struct {
		result1 *time.Duration
	}{result1}
}

func (fake *FakeFlag) DurationReturnsOnCall(i int, result1 *time.Duration) {
	fake.durationMutex.Lock()
	defer fake.durationMutex.Unlock()
	fake.DurationStub = nil
	if fake.durationReturnsOnCall == nil {
		fake.durationReturnsOnCall = make(map[int]struct {
			result1 *time.Duration
		})
	}
	fake.durationReturnsOnCall[i] = struct {
		result1 *time.Duration
	}{result1}
}

func (fake *FakeFlag) DurationVar(arg1 *time.Duration, arg2 string, arg3 time.Duration, arg4 string) {
	fake.durationVarMutex.Lock()
	fake.durationVarArgsForCall = append(fake.durationVarArgsForCall, struct {
		arg1 *time.Duration
		arg2 string
		arg3 time.Duration
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DurationVarStub
	fake.recordInvocation("DurationVar", []interface{}{arg1, arg2, arg3, arg4})
	fake.durationVarMutex.Unlock()
	if stub != nil {
		fake.DurationVarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) DurationVarCallCount() int {
	fake.durationVarMutex.RLock()
	defer fake.durationVarMutex.RUnlock()
	return len(fake.durationVarArgsForCall)
}

func (fake *FakeFlag) DurationVarCalls(stub func(*time.Duration, string, time.Duration, string)) {
	fake.durationVarMutex.Lock()
	defer fake.durationVarMutex.Unlock()
	fake.DurationVarStub = stub
}

func (fake *FakeFlag) DurationVarArgsForCall(i int) (*time.Duration, string, time.Duration, string) {
	fake.durationVarMutex.RLock()
	defer fake.durationVarMutex.RUnlock()
	argsForCall := fake.durationVarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) Float64(arg1 string, arg2 float64, arg3 string) *float64 {
	fake.float64Mutex.Lock()
	ret, specificReturn := fake.float64ReturnsOnCall[len(fake.float64ArgsForCall)]
	fake.float64ArgsForCall = append(fake.float64ArgsForCall, struct {
		arg1 string
		arg2 float64
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.Float64Stub
	fakeReturns := fake.float64Returns
	fake.recordInvocation("Float64", []interface{}{arg1, arg2, arg3})
	fake.float64Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) Float64CallCount() int {
	fake.float64Mutex.RLock()
	defer fake.float64Mutex.RUnlock()
	return len(fake.float64ArgsForCall)
}

func (fake *FakeFlag) Float64Calls(stub func(string, float64, string) *float64) {
	fake.float64Mutex.Lock()
	defer fake.float64Mutex.Unlock()
	fake.Float64Stub = stub
}

func (fake *FakeFlag) Float64ArgsForCall(i int) (string, float64, string) {
	fake.float64Mutex.RLock()
	defer fake.float64Mutex.RUnlock()
	argsForCall := fake.float64ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) Float64Returns(result1 *float64) {
	fake.float64Mutex.Lock()
	defer fake.float64Mutex.Unlock()
	fake.Float64Stub = nil
	fake.float64Returns = struct {
		result1 *float64
	}{result1}
}

func (fake *FakeFlag) Float64ReturnsOnCall(i int, result1 *float64) {
	fake.float64Mutex.Lock()
	defer fake.float64Mutex.Unlock()
	fake.Float64Stub = nil
	if fake.float64ReturnsOnCall == nil {
		fake.float64ReturnsOnCall = make(map[int]struct {
			result1 *float64
		})
	}
	fake.float64ReturnsOnCall[i] = struct {
		result1 *float64
	}{result1}
}

func (fake *FakeFlag) Float64Var(arg1 *float64, arg2 string, arg3 float64, arg4 string) {
	fake.float64VarMutex.Lock()
	fake.float64VarArgsForCall = append(fake.float64VarArgsForCall, struct {
		arg1 *float64
		arg2 string
		arg3 float64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.Float64VarStub
	fake.recordInvocation("Float64Var", []interface{}{arg1, arg2, arg3, arg4})
	fake.float64VarMutex.Unlock()
	if stub != nil {
		fake.Float64VarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) Float64VarCallCount() int {
	fake.float64VarMutex.RLock()
	defer fake.float64VarMutex.RUnlock()
	return len(fake.float64VarArgsForCall)
}

func (fake *FakeFlag) Float64VarCalls(stub func(*float64, string, float64, string)) {
	fake.float64VarMutex.Lock()
	defer fake.float64VarMutex.Unlock()
	fake.Float64VarStub = stub
}

func (fake *FakeFlag) Float64VarArgsForCall(i int) (*float64, string, float64, string) {
	fake.float64VarMutex.RLock()
	defer fake.float64VarMutex.RUnlock()
	argsForCall := fake.float64VarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) Func(arg1 string, arg2 string, arg3 func(string) error) {
	fake.funcMutex.Lock()
	fake.funcArgsForCall = append(fake.funcArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 func(string) error
	}{arg1, arg2, arg3})
	stub := fake.FuncStub
	fake.recordInvocation("Func", []interface{}{arg1, arg2, arg3})
	fake.funcMutex.Unlock()
	if stub != nil {
		fake.FuncStub(arg1, arg2, arg3)
	}
}

func (fake *FakeFlag) FuncCallCount() int {
	fake.funcMutex.RLock()
	defer fake.funcMutex.RUnlock()
	return len(fake.funcArgsForCall)
}

func (fake *FakeFlag) FuncCalls(stub func(string, string, func(string) error)) {
	fake.funcMutex.Lock()
	defer fake.funcMutex.Unlock()
	fake.FuncStub = stub
}

func (fake *FakeFlag) FuncArgsForCall(i int) (string, string, func(string) error) {
	fake.funcMutex.RLock()
	defer fake.funcMutex.RUnlock()
	argsForCall := fake.funcArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) Int(arg1 string, arg2 int, arg3 string) *int {
	fake.intMutex.Lock()
	ret, specificReturn := fake.intReturnsOnCall[len(fake.intArgsForCall)]
	fake.intArgsForCall = append(fake.intArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.IntStub
	fakeReturns := fake.intReturns
	fake.recordInvocation("Int", []interface{}{arg1, arg2, arg3})
	fake.intMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) IntCallCount() int {
	fake.intMutex.RLock()
	defer fake.intMutex.RUnlock()
	return len(fake.intArgsForCall)
}

func (fake *FakeFlag) IntCalls(stub func(string, int, string) *int) {
	fake.intMutex.Lock()
	defer fake.intMutex.Unlock()
	fake.IntStub = stub
}

func (fake *FakeFlag) IntArgsForCall(i int) (string, int, string) {
	fake.intMutex.RLock()
	defer fake.intMutex.RUnlock()
	argsForCall := fake.intArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) IntReturns(result1 *int) {
	fake.intMutex.Lock()
	defer fake.intMutex.Unlock()
	fake.IntStub = nil
	fake.intReturns = struct {
		result1 *int
	}{result1}
}

func (fake *FakeFlag) IntReturnsOnCall(i int, result1 *int) {
	fake.intMutex.Lock()
	defer fake.intMutex.Unlock()
	fake.IntStub = nil
	if fake.intReturnsOnCall == nil {
		fake.intReturnsOnCall = make(map[int]struct {
			result1 *int
		})
	}
	fake.intReturnsOnCall[i] = struct {
		result1 *int
	}{result1}
}

func (fake *FakeFlag) Int64(arg1 string, arg2 int64, arg3 string) *int64 {
	fake.int64Mutex.Lock()
	ret, specificReturn := fake.int64ReturnsOnCall[len(fake.int64ArgsForCall)]
	fake.int64ArgsForCall = append(fake.int64ArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.Int64Stub
	fakeReturns := fake.int64Returns
	fake.recordInvocation("Int64", []interface{}{arg1, arg2, arg3})
	fake.int64Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) Int64CallCount() int {
	fake.int64Mutex.RLock()
	defer fake.int64Mutex.RUnlock()
	return len(fake.int64ArgsForCall)
}

func (fake *FakeFlag) Int64Calls(stub func(string, int64, string) *int64) {
	fake.int64Mutex.Lock()
	defer fake.int64Mutex.Unlock()
	fake.Int64Stub = stub
}

func (fake *FakeFlag) Int64ArgsForCall(i int) (string, int64, string) {
	fake.int64Mutex.RLock()
	defer fake.int64Mutex.RUnlock()
	argsForCall := fake.int64ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) Int64Returns(result1 *int64) {
	fake.int64Mutex.Lock()
	defer fake.int64Mutex.Unlock()
	fake.Int64Stub = nil
	fake.int64Returns = struct {
		result1 *int64
	}{result1}
}

func (fake *FakeFlag) Int64ReturnsOnCall(i int, result1 *int64) {
	fake.int64Mutex.Lock()
	defer fake.int64Mutex.Unlock()
	fake.Int64Stub = nil
	if fake.int64ReturnsOnCall == nil {
		fake.int64ReturnsOnCall = make(map[int]struct {
			result1 *int64
		})
	}
	fake.int64ReturnsOnCall[i] = struct {
		result1 *int64
	}{result1}
}

func (fake *FakeFlag) Int64Var(arg1 *int64, arg2 string, arg3 int64, arg4 string) {
	fake.int64VarMutex.Lock()
	fake.int64VarArgsForCall = append(fake.int64VarArgsForCall, struct {
		arg1 *int64
		arg2 string
		arg3 int64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.Int64VarStub
	fake.recordInvocation("Int64Var", []interface{}{arg1, arg2, arg3, arg4})
	fake.int64VarMutex.Unlock()
	if stub != nil {
		fake.Int64VarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) Int64VarCallCount() int {
	fake.int64VarMutex.RLock()
	defer fake.int64VarMutex.RUnlock()
	return len(fake.int64VarArgsForCall)
}

func (fake *FakeFlag) Int64VarCalls(stub func(*int64, string, int64, string)) {
	fake.int64VarMutex.Lock()
	defer fake.int64VarMutex.Unlock()
	fake.Int64VarStub = stub
}

func (fake *FakeFlag) Int64VarArgsForCall(i int) (*int64, string, int64, string) {
	fake.int64VarMutex.RLock()
	defer fake.int64VarMutex.RUnlock()
	argsForCall := fake.int64VarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) IntVar(arg1 *int, arg2 string, arg3 int, arg4 string) {
	fake.intVarMutex.Lock()
	fake.intVarArgsForCall = append(fake.intVarArgsForCall, struct {
		arg1 *int
		arg2 string
		arg3 int
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.IntVarStub
	fake.recordInvocation("IntVar", []interface{}{arg1, arg2, arg3, arg4})
	fake.intVarMutex.Unlock()
	if stub != nil {
		fake.IntVarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) IntVarCallCount() int {
	fake.intVarMutex.RLock()
	defer fake.intVarMutex.RUnlock()
	return len(fake.intVarArgsForCall)
}

func (fake *FakeFlag) IntVarCalls(stub func(*int, string, int, string)) {
	fake.intVarMutex.Lock()
	defer fake.intVarMutex.Unlock()
	fake.IntVarStub = stub
}

func (fake *FakeFlag) IntVarArgsForCall(i int) (*int, string, int, string) {
	fake.intVarMutex.RLock()
	defer fake.intVarMutex.RUnlock()
	argsForCall := fake.intVarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) Lookup(arg1 string) *flag.Flag {
	fake.lookupMutex.Lock()
	ret, specificReturn := fake.lookupReturnsOnCall[len(fake.lookupArgsForCall)]
	fake.lookupArgsForCall = append(fake.lookupArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LookupStub
	fakeReturns := fake.lookupReturns
	fake.recordInvocation("Lookup", []interface{}{arg1})
	fake.lookupMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) LookupCallCount() int {
	fake.lookupMutex.RLock()
	defer fake.lookupMutex.RUnlock()
	return len(fake.lookupArgsForCall)
}

func (fake *FakeFlag) LookupCalls(stub func(string) *flag.Flag) {
	fake.lookupMutex.Lock()
	defer fake.lookupMutex.Unlock()
	fake.LookupStub = stub
}

func (fake *FakeFlag) LookupArgsForCall(i int) string {
	fake.lookupMutex.RLock()
	defer fake.lookupMutex.RUnlock()
	argsForCall := fake.lookupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFlag) LookupReturns(result1 *flag.Flag) {
	fake.lookupMutex.Lock()
	defer fake.lookupMutex.Unlock()
	fake.LookupStub = nil
	fake.lookupReturns = struct {
		result1 *flag.Flag
	}{result1}
}

func (fake *FakeFlag) LookupReturnsOnCall(i int, result1 *flag.Flag) {
	fake.lookupMutex.Lock()
	defer fake.lookupMutex.Unlock()
	fake.LookupStub = nil
	if fake.lookupReturnsOnCall == nil {
		fake.lookupReturnsOnCall = make(map[int]struct {
			result1 *flag.Flag
		})
	}
	fake.lookupReturnsOnCall[i] = struct {
		result1 *flag.Flag
	}{result1}
}

func (fake *FakeFlag) NArg() int {
	fake.nArgMutex.Lock()
	ret, specificReturn := fake.nArgReturnsOnCall[len(fake.nArgArgsForCall)]
	fake.nArgArgsForCall = append(fake.nArgArgsForCall, struct {
	}{})
	stub := fake.NArgStub
	fakeReturns := fake.nArgReturns
	fake.recordInvocation("NArg", []interface{}{})
	fake.nArgMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) NArgCallCount() int {
	fake.nArgMutex.RLock()
	defer fake.nArgMutex.RUnlock()
	return len(fake.nArgArgsForCall)
}

func (fake *FakeFlag) NArgCalls(stub func() int) {
	fake.nArgMutex.Lock()
	defer fake.nArgMutex.Unlock()
	fake.NArgStub = stub
}

func (fake *FakeFlag) NArgReturns(result1 int) {
	fake.nArgMutex.Lock()
	defer fake.nArgMutex.Unlock()
	fake.NArgStub = nil
	fake.nArgReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeFlag) NArgReturnsOnCall(i int, result1 int) {
	fake.nArgMutex.Lock()
	defer fake.nArgMutex.Unlock()
	fake.NArgStub = nil
	if fake.nArgReturnsOnCall == nil {
		fake.nArgReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.nArgReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeFlag) NFlag() int {
	fake.nFlagMutex.Lock()
	ret, specificReturn := fake.nFlagReturnsOnCall[len(fake.nFlagArgsForCall)]
	fake.nFlagArgsForCall = append(fake.nFlagArgsForCall, struct {
	}{})
	stub := fake.NFlagStub
	fakeReturns := fake.nFlagReturns
	fake.recordInvocation("NFlag", []interface{}{})
	fake.nFlagMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) NFlagCallCount() int {
	fake.nFlagMutex.RLock()
	defer fake.nFlagMutex.RUnlock()
	return len(fake.nFlagArgsForCall)
}

func (fake *FakeFlag) NFlagCalls(stub func() int) {
	fake.nFlagMutex.Lock()
	defer fake.nFlagMutex.Unlock()
	fake.NFlagStub = stub
}

func (fake *FakeFlag) NFlagReturns(result1 int) {
	fake.nFlagMutex.Lock()
	defer fake.nFlagMutex.Unlock()
	fake.NFlagStub = nil
	fake.nFlagReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeFlag) NFlagReturnsOnCall(i int, result1 int) {
	fake.nFlagMutex.Lock()
	defer fake.nFlagMutex.Unlock()
	fake.NFlagStub = nil
	if fake.nFlagReturnsOnCall == nil {
		fake.nFlagReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.nFlagReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeFlag) NewFlagSet(arg1 string, arg2 flag.ErrorHandling) *flag.FlagSet {
	fake.newFlagSetMutex.Lock()
	ret, specificReturn := fake.newFlagSetReturnsOnCall[len(fake.newFlagSetArgsForCall)]
	fake.newFlagSetArgsForCall = append(fake.newFlagSetArgsForCall, struct {
		arg1 string
		arg2 flag.ErrorHandling
	}{arg1, arg2})
	stub := fake.NewFlagSetStub
	fakeReturns := fake.newFlagSetReturns
	fake.recordInvocation("NewFlagSet", []interface{}{arg1, arg2})
	fake.newFlagSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) NewFlagSetCallCount() int {
	fake.newFlagSetMutex.RLock()
	defer fake.newFlagSetMutex.RUnlock()
	return len(fake.newFlagSetArgsForCall)
}

func (fake *FakeFlag) NewFlagSetCalls(stub func(string, flag.ErrorHandling) *flag.FlagSet) {
	fake.newFlagSetMutex.Lock()
	defer fake.newFlagSetMutex.Unlock()
	fake.NewFlagSetStub = stub
}

func (fake *FakeFlag) NewFlagSetArgsForCall(i int) (string, flag.ErrorHandling) {
	fake.newFlagSetMutex.RLock()
	defer fake.newFlagSetMutex.RUnlock()
	argsForCall := fake.newFlagSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFlag) NewFlagSetReturns(result1 *flag.FlagSet) {
	fake.newFlagSetMutex.Lock()
	defer fake.newFlagSetMutex.Unlock()
	fake.NewFlagSetStub = nil
	fake.newFlagSetReturns = struct {
		result1 *flag.FlagSet
	}{result1}
}

func (fake *FakeFlag) NewFlagSetReturnsOnCall(i int, result1 *flag.FlagSet) {
	fake.newFlagSetMutex.Lock()
	defer fake.newFlagSetMutex.Unlock()
	fake.NewFlagSetStub = nil
	if fake.newFlagSetReturnsOnCall == nil {
		fake.newFlagSetReturnsOnCall = make(map[int]struct {
			result1 *flag.FlagSet
		})
	}
	fake.newFlagSetReturnsOnCall[i] = struct {
		result1 *flag.FlagSet
	}{result1}
}

func (fake *FakeFlag) Parse() {
	fake.parseMutex.Lock()
	fake.parseArgsForCall = append(fake.parseArgsForCall, struct {
	}{})
	stub := fake.ParseStub
	fake.recordInvocation("Parse", []interface{}{})
	fake.parseMutex.Unlock()
	if stub != nil {
		fake.ParseStub()
	}
}

func (fake *FakeFlag) ParseCallCount() int {
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	return len(fake.parseArgsForCall)
}

func (fake *FakeFlag) ParseCalls(stub func()) {
	fake.parseMutex.Lock()
	defer fake.parseMutex.Unlock()
	fake.ParseStub = stub
}

func (fake *FakeFlag) Parsed() bool {
	fake.parsedMutex.Lock()
	ret, specificReturn := fake.parsedReturnsOnCall[len(fake.parsedArgsForCall)]
	fake.parsedArgsForCall = append(fake.parsedArgsForCall, struct {
	}{})
	stub := fake.ParsedStub
	fakeReturns := fake.parsedReturns
	fake.recordInvocation("Parsed", []interface{}{})
	fake.parsedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) ParsedCallCount() int {
	fake.parsedMutex.RLock()
	defer fake.parsedMutex.RUnlock()
	return len(fake.parsedArgsForCall)
}

func (fake *FakeFlag) ParsedCalls(stub func() bool) {
	fake.parsedMutex.Lock()
	defer fake.parsedMutex.Unlock()
	fake.ParsedStub = stub
}

func (fake *FakeFlag) ParsedReturns(result1 bool) {
	fake.parsedMutex.Lock()
	defer fake.parsedMutex.Unlock()
	fake.ParsedStub = nil
	fake.parsedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFlag) ParsedReturnsOnCall(i int, result1 bool) {
	fake.parsedMutex.Lock()
	defer fake.parsedMutex.Unlock()
	fake.ParsedStub = nil
	if fake.parsedReturnsOnCall == nil {
		fake.parsedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.parsedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFlag) PrintDefaults() {
	fake.printDefaultsMutex.Lock()
	fake.printDefaultsArgsForCall = append(fake.printDefaultsArgsForCall, struct {
	}{})
	stub := fake.PrintDefaultsStub
	fake.recordInvocation("PrintDefaults", []interface{}{})
	fake.printDefaultsMutex.Unlock()
	if stub != nil {
		fake.PrintDefaultsStub()
	}
}

func (fake *FakeFlag) PrintDefaultsCallCount() int {
	fake.printDefaultsMutex.RLock()
	defer fake.printDefaultsMutex.RUnlock()
	return len(fake.printDefaultsArgsForCall)
}

func (fake *FakeFlag) PrintDefaultsCalls(stub func()) {
	fake.printDefaultsMutex.Lock()
	defer fake.printDefaultsMutex.Unlock()
	fake.PrintDefaultsStub = stub
}

func (fake *FakeFlag) Set(arg1 string, arg2 string) error {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetStub
	fakeReturns := fake.setReturns
	fake.recordInvocation("Set", []interface{}{arg1, arg2})
	fake.setMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeFlag) SetCalls(stub func(string, string) error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakeFlag) SetArgsForCall(i int) (string, string) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFlag) SetReturns(result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFlag) SetReturnsOnCall(i int, result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFlag) String(arg1 string, arg2 string, arg3 string) *string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.StringStub
	fakeReturns := fake.stringReturns
	fake.recordInvocation("String", []interface{}{arg1, arg2, arg3})
	fake.stringMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeFlag) StringCalls(stub func(string, string, string) *string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *FakeFlag) StringArgsForCall(i int) (string, string, string) {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	argsForCall := fake.stringArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) StringReturns(result1 *string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeFlag) StringReturnsOnCall(i int, result1 *string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeFlag) StringVar(arg1 *string, arg2 string, arg3 string, arg4 string) {
	fake.stringVarMutex.Lock()
	fake.stringVarArgsForCall = append(fake.stringVarArgsForCall, struct {
		arg1 *string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.StringVarStub
	fake.recordInvocation("StringVar", []interface{}{arg1, arg2, arg3, arg4})
	fake.stringVarMutex.Unlock()
	if stub != nil {
		fake.StringVarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) StringVarCallCount() int {
	fake.stringVarMutex.RLock()
	defer fake.stringVarMutex.RUnlock()
	return len(fake.stringVarArgsForCall)
}

func (fake *FakeFlag) StringVarCalls(stub func(*string, string, string, string)) {
	fake.stringVarMutex.Lock()
	defer fake.stringVarMutex.Unlock()
	fake.StringVarStub = stub
}

func (fake *FakeFlag) StringVarArgsForCall(i int) (*string, string, string, string) {
	fake.stringVarMutex.RLock()
	defer fake.stringVarMutex.RUnlock()
	argsForCall := fake.stringVarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) Uint(arg1 string, arg2 uint, arg3 string) *uint {
	fake.uintMutex.Lock()
	ret, specificReturn := fake.uintReturnsOnCall[len(fake.uintArgsForCall)]
	fake.uintArgsForCall = append(fake.uintArgsForCall, struct {
		arg1 string
		arg2 uint
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UintStub
	fakeReturns := fake.uintReturns
	fake.recordInvocation("Uint", []interface{}{arg1, arg2, arg3})
	fake.uintMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) UintCallCount() int {
	fake.uintMutex.RLock()
	defer fake.uintMutex.RUnlock()
	return len(fake.uintArgsForCall)
}

func (fake *FakeFlag) UintCalls(stub func(string, uint, string) *uint) {
	fake.uintMutex.Lock()
	defer fake.uintMutex.Unlock()
	fake.UintStub = stub
}

func (fake *FakeFlag) UintArgsForCall(i int) (string, uint, string) {
	fake.uintMutex.RLock()
	defer fake.uintMutex.RUnlock()
	argsForCall := fake.uintArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) UintReturns(result1 *uint) {
	fake.uintMutex.Lock()
	defer fake.uintMutex.Unlock()
	fake.UintStub = nil
	fake.uintReturns = struct {
		result1 *uint
	}{result1}
}

func (fake *FakeFlag) UintReturnsOnCall(i int, result1 *uint) {
	fake.uintMutex.Lock()
	defer fake.uintMutex.Unlock()
	fake.UintStub = nil
	if fake.uintReturnsOnCall == nil {
		fake.uintReturnsOnCall = make(map[int]struct {
			result1 *uint
		})
	}
	fake.uintReturnsOnCall[i] = struct {
		result1 *uint
	}{result1}
}

func (fake *FakeFlag) Uint64(arg1 string, arg2 uint64, arg3 string) *uint64 {
	fake.uint64Mutex.Lock()
	ret, specificReturn := fake.uint64ReturnsOnCall[len(fake.uint64ArgsForCall)]
	fake.uint64ArgsForCall = append(fake.uint64ArgsForCall, struct {
		arg1 string
		arg2 uint64
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.Uint64Stub
	fakeReturns := fake.uint64Returns
	fake.recordInvocation("Uint64", []interface{}{arg1, arg2, arg3})
	fake.uint64Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFlag) Uint64CallCount() int {
	fake.uint64Mutex.RLock()
	defer fake.uint64Mutex.RUnlock()
	return len(fake.uint64ArgsForCall)
}

func (fake *FakeFlag) Uint64Calls(stub func(string, uint64, string) *uint64) {
	fake.uint64Mutex.Lock()
	defer fake.uint64Mutex.Unlock()
	fake.Uint64Stub = stub
}

func (fake *FakeFlag) Uint64ArgsForCall(i int) (string, uint64, string) {
	fake.uint64Mutex.RLock()
	defer fake.uint64Mutex.RUnlock()
	argsForCall := fake.uint64ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) Uint64Returns(result1 *uint64) {
	fake.uint64Mutex.Lock()
	defer fake.uint64Mutex.Unlock()
	fake.Uint64Stub = nil
	fake.uint64Returns = struct {
		result1 *uint64
	}{result1}
}

func (fake *FakeFlag) Uint64ReturnsOnCall(i int, result1 *uint64) {
	fake.uint64Mutex.Lock()
	defer fake.uint64Mutex.Unlock()
	fake.Uint64Stub = nil
	if fake.uint64ReturnsOnCall == nil {
		fake.uint64ReturnsOnCall = make(map[int]struct {
			result1 *uint64
		})
	}
	fake.uint64ReturnsOnCall[i] = struct {
		result1 *uint64
	}{result1}
}

func (fake *FakeFlag) Uint64Var(arg1 *uint64, arg2 string, arg3 uint64, arg4 string) {
	fake.uint64VarMutex.Lock()
	fake.uint64VarArgsForCall = append(fake.uint64VarArgsForCall, struct {
		arg1 *uint64
		arg2 string
		arg3 uint64
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.Uint64VarStub
	fake.recordInvocation("Uint64Var", []interface{}{arg1, arg2, arg3, arg4})
	fake.uint64VarMutex.Unlock()
	if stub != nil {
		fake.Uint64VarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) Uint64VarCallCount() int {
	fake.uint64VarMutex.RLock()
	defer fake.uint64VarMutex.RUnlock()
	return len(fake.uint64VarArgsForCall)
}

func (fake *FakeFlag) Uint64VarCalls(stub func(*uint64, string, uint64, string)) {
	fake.uint64VarMutex.Lock()
	defer fake.uint64VarMutex.Unlock()
	fake.Uint64VarStub = stub
}

func (fake *FakeFlag) Uint64VarArgsForCall(i int) (*uint64, string, uint64, string) {
	fake.uint64VarMutex.RLock()
	defer fake.uint64VarMutex.RUnlock()
	argsForCall := fake.uint64VarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) UintVar(arg1 *uint, arg2 string, arg3 uint, arg4 string) {
	fake.uintVarMutex.Lock()
	fake.uintVarArgsForCall = append(fake.uintVarArgsForCall, struct {
		arg1 *uint
		arg2 string
		arg3 uint
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.UintVarStub
	fake.recordInvocation("UintVar", []interface{}{arg1, arg2, arg3, arg4})
	fake.uintVarMutex.Unlock()
	if stub != nil {
		fake.UintVarStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeFlag) UintVarCallCount() int {
	fake.uintVarMutex.RLock()
	defer fake.uintVarMutex.RUnlock()
	return len(fake.uintVarArgsForCall)
}

func (fake *FakeFlag) UintVarCalls(stub func(*uint, string, uint, string)) {
	fake.uintVarMutex.Lock()
	defer fake.uintVarMutex.Unlock()
	fake.UintVarStub = stub
}

func (fake *FakeFlag) UintVarArgsForCall(i int) (*uint, string, uint, string) {
	fake.uintVarMutex.RLock()
	defer fake.uintVarMutex.RUnlock()
	argsForCall := fake.uintVarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeFlag) UnquoteUsage(arg1 *flag.Flag) (string, string) {
	fake.unquoteUsageMutex.Lock()
	ret, specificReturn := fake.unquoteUsageReturnsOnCall[len(fake.unquoteUsageArgsForCall)]
	fake.unquoteUsageArgsForCall = append(fake.unquoteUsageArgsForCall, struct {
		arg1 *flag.Flag
	}{arg1})
	stub := fake.UnquoteUsageStub
	fakeReturns := fake.unquoteUsageReturns
	fake.recordInvocation("UnquoteUsage", []interface{}{arg1})
	fake.unquoteUsageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFlag) UnquoteUsageCallCount() int {
	fake.unquoteUsageMutex.RLock()
	defer fake.unquoteUsageMutex.RUnlock()
	return len(fake.unquoteUsageArgsForCall)
}

func (fake *FakeFlag) UnquoteUsageCalls(stub func(*flag.Flag) (string, string)) {
	fake.unquoteUsageMutex.Lock()
	defer fake.unquoteUsageMutex.Unlock()
	fake.UnquoteUsageStub = stub
}

func (fake *FakeFlag) UnquoteUsageArgsForCall(i int) *flag.Flag {
	fake.unquoteUsageMutex.RLock()
	defer fake.unquoteUsageMutex.RUnlock()
	argsForCall := fake.unquoteUsageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFlag) UnquoteUsageReturns(result1 string, result2 string) {
	fake.unquoteUsageMutex.Lock()
	defer fake.unquoteUsageMutex.Unlock()
	fake.UnquoteUsageStub = nil
	fake.unquoteUsageReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeFlag) UnquoteUsageReturnsOnCall(i int, result1 string, result2 string) {
	fake.unquoteUsageMutex.Lock()
	defer fake.unquoteUsageMutex.Unlock()
	fake.UnquoteUsageStub = nil
	if fake.unquoteUsageReturnsOnCall == nil {
		fake.unquoteUsageReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.unquoteUsageReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeFlag) Var(arg1 flag.Value, arg2 string, arg3 string) {
	fake.varMutex.Lock()
	fake.varArgsForCall = append(fake.varArgsForCall, struct {
		arg1 flag.Value
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.VarStub
	fake.recordInvocation("Var", []interface{}{arg1, arg2, arg3})
	fake.varMutex.Unlock()
	if stub != nil {
		fake.VarStub(arg1, arg2, arg3)
	}
}

func (fake *FakeFlag) VarCallCount() int {
	fake.varMutex.RLock()
	defer fake.varMutex.RUnlock()
	return len(fake.varArgsForCall)
}

func (fake *FakeFlag) VarCalls(stub func(flag.Value, string, string)) {
	fake.varMutex.Lock()
	defer fake.varMutex.Unlock()
	fake.VarStub = stub
}

func (fake *FakeFlag) VarArgsForCall(i int) (flag.Value, string, string) {
	fake.varMutex.RLock()
	defer fake.varMutex.RUnlock()
	argsForCall := fake.varArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFlag) Visit(arg1 func(*flag.Flag)) {
	fake.visitMutex.Lock()
	fake.visitArgsForCall = append(fake.visitArgsForCall, struct {
		arg1 func(*flag.Flag)
	}{arg1})
	stub := fake.VisitStub
	fake.recordInvocation("Visit", []interface{}{arg1})
	fake.visitMutex.Unlock()
	if stub != nil {
		fake.VisitStub(arg1)
	}
}

func (fake *FakeFlag) VisitCallCount() int {
	fake.visitMutex.RLock()
	defer fake.visitMutex.RUnlock()
	return len(fake.visitArgsForCall)
}

func (fake *FakeFlag) VisitCalls(stub func(func(*flag.Flag))) {
	fake.visitMutex.Lock()
	defer fake.visitMutex.Unlock()
	fake.VisitStub = stub
}

func (fake *FakeFlag) VisitArgsForCall(i int) func(*flag.Flag) {
	fake.visitMutex.RLock()
	defer fake.visitMutex.RUnlock()
	argsForCall := fake.visitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFlag) VisitAll(arg1 func(*flag.Flag)) {
	fake.visitAllMutex.Lock()
	fake.visitAllArgsForCall = append(fake.visitAllArgsForCall, struct {
		arg1 func(*flag.Flag)
	}{arg1})
	stub := fake.VisitAllStub
	fake.recordInvocation("VisitAll", []interface{}{arg1})
	fake.visitAllMutex.Unlock()
	if stub != nil {
		fake.VisitAllStub(arg1)
	}
}

func (fake *FakeFlag) VisitAllCallCount() int {
	fake.visitAllMutex.RLock()
	defer fake.visitAllMutex.RUnlock()
	return len(fake.visitAllArgsForCall)
}

func (fake *FakeFlag) VisitAllCalls(stub func(func(*flag.Flag))) {
	fake.visitAllMutex.Lock()
	defer fake.visitAllMutex.Unlock()
	fake.VisitAllStub = stub
}

func (fake *FakeFlag) VisitAllArgsForCall(i int) func(*flag.Flag) {
	fake.visitAllMutex.RLock()
	defer fake.visitAllMutex.RUnlock()
	argsForCall := fake.visitAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFlag) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.argMutex.RLock()
	defer fake.argMutex.RUnlock()
	fake.argsMutex.RLock()
	defer fake.argsMutex.RUnlock()
	fake.boolMutex.RLock()
	defer fake.boolMutex.RUnlock()
	fake.boolVarMutex.RLock()
	defer fake.boolVarMutex.RUnlock()
	fake.durationMutex.RLock()
	defer fake.durationMutex.RUnlock()
	fake.durationVarMutex.RLock()
	defer fake.durationVarMutex.RUnlock()
	fake.float64Mutex.RLock()
	defer fake.float64Mutex.RUnlock()
	fake.float64VarMutex.RLock()
	defer fake.float64VarMutex.RUnlock()
	fake.funcMutex.RLock()
	defer fake.funcMutex.RUnlock()
	fake.intMutex.RLock()
	defer fake.intMutex.RUnlock()
	fake.int64Mutex.RLock()
	defer fake.int64Mutex.RUnlock()
	fake.int64VarMutex.RLock()
	defer fake.int64VarMutex.RUnlock()
	fake.intVarMutex.RLock()
	defer fake.intVarMutex.RUnlock()
	fake.lookupMutex.RLock()
	defer fake.lookupMutex.RUnlock()
	fake.nArgMutex.RLock()
	defer fake.nArgMutex.RUnlock()
	fake.nFlagMutex.RLock()
	defer fake.nFlagMutex.RUnlock()
	fake.newFlagSetMutex.RLock()
	defer fake.newFlagSetMutex.RUnlock()
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	fake.parsedMutex.RLock()
	defer fake.parsedMutex.RUnlock()
	fake.printDefaultsMutex.RLock()
	defer fake.printDefaultsMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.stringVarMutex.RLock()
	defer fake.stringVarMutex.RUnlock()
	fake.uintMutex.RLock()
	defer fake.uintMutex.RUnlock()
	fake.uint64Mutex.RLock()
	defer fake.uint64Mutex.RUnlock()
	fake.uint64VarMutex.RLock()
	defer fake.uint64VarMutex.RUnlock()
	fake.uintVarMutex.RLock()
	defer fake.uintVarMutex.RUnlock()
	fake.unquoteUsageMutex.RLock()
	defer fake.unquoteUsageMutex.RUnlock()
	fake.varMutex.RLock()
	defer fake.varMutex.RUnlock()
	fake.visitMutex.RLock()
	defer fake.visitMutex.RUnlock()
	fake.visitAllMutex.RLock()
	defer fake.visitAllMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFlag) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ flagshim.Flag = new(FakeFlag)
